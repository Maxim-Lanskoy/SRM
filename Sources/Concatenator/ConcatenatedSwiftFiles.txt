**Request: "-=-=-=-".**

Hi! I'm making SRM (Swift Running Manager).

Executable cli Swift tool project description:
SRM is a command-line tool written in Swift that functions as a process manager, similar to pm2. It is designed to manage and monitor the execution of various scripts, commands, executables, or applications on macOS and Linux systems. SRM allows users to start, stop, restart, and monitor processes, as well as view logs and manage process lifecycles.

Purpose:
The primary goal of SRM is to provide developers and system administrators with a lightweight and efficient tool to manage long-running processes without the need to modify the code of the processes being managed. It is particularly useful for running and monitoring scripts or applications where source code modification is not feasible.

Key Features:
Process Management Commands:
start: Start a new process or all stopped processes.
Supports specifying a custom name for the process.
Includes a --restart flag to automatically restart processes if they exit unexpectedly.
Introduces a --watch flag to display real-time output of the process.
stop: Stop a running process by name or index, or stop all processes.
restart: Restart a process by name or index, or restart all processes.
list (ls): List all managed processes with details like status, PID, CPU and memory usage, and start time.
logs: View logs of a process by name or index, or view logs for all processes.
Supports tailing logs in real-time or viewing the last N lines.
Monitoring Service:
monitor: Start a monitoring service that checks the health of managed processes and restarts them if they crash (when --restart is enabled).
Setup and Cleanup:
setup: Sets up SRM by building the release version and adding it to the system PATH.
destroy: Removes SRM setup and associated files.
Process Information Management:
Stores process information in JSON files for persistence across sessions.
Manages log files, including log rotation when files exceed a specified size.
Cross-Platform Support:
Designed to work on macOS and Linux systems.
Uses Swift's Process API for process execution and management.
No Dependency on Modifying Managed Processes:
Capable of managing processes without requiring changes to their source code.
Handles output buffering issues by providing the --watch flag to capture and display process output in real-time.
Similarities to pm2:

Like pm2, SRM allows for the management of multiple processes, providing start, stop, and restart functionalities.
Offers process monitoring and automatic restarts for crashed processes.
Provides logging capabilities and real-time output viewing.
Use Cases:

Managing background services or daemons.
Running and monitoring scripts or applications written in Swift, Python, shell, or other languages.
Deploying applications that need to run continuously and be monitored for crashes or unexpected exits.
Environments where modifying the source code of the managed processes is not possible or desirable.
Additional Information:

Logging: SRM manages log files for each process, storing them in a designated logs directory (~/.srm/logs). It supports log rotation to prevent uncontrolled growth of log files.
Process Identification: Processes can be managed by name or by their index in the process list.
Extensibility: The tool is designed with extensibility in mind, allowing for future enhancements and additional features as needed.
User-Friendly Interface: Provides clear and concise command-line output, including tables for listing processes and helpful messages for user actions.
Example Commands:

Start a process and display its output:
css
Copy code
srm start /path/to/app --name MyApp --watch
Stop a process by name:
arduino
Copy code
srm stop MyApp
View logs for a process:
Copy code
srm logs MyApp
List all managed processes:
Copy code
srm list
Conclusion:

SRM aims to be a simple yet powerful tool for process management in the development and deployment of applications. By providing essential features similar to pm2, it helps users manage processes effectively without the overhead of larger process management systems.

Project File Structure:
üìÅ Sources
    üìÅ SRM
        üìÑ main.swift
        üìÅ CLI
            üìÑ delete.swift
            üìÑ destroy.swift
            üìÑ list.swift
            üìÑ logs.swift
            üìÑ minotor.swift
            üìÑ restart.swift
            üìÑ setup.swift
            üìÑ start.swift
            üìÑ stop.swift
        üìÅ Utils
            üìÑ ProcessManager.swift

// File: delete.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/delete.swift
//
//  delete.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 10.10.2024.
//

import ArgumentParser
import Foundation

extension SRM {
    struct Delete: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Delete a process from SRM.",
            discussion: """
            The `delete` command removes a process from SRM's management.

            Examples:
              - Delete a process by name: `srm delete MyApp`
              - Delete a process by index: `srm delete 1`
              - Delete all processes: `srm delete all`
            """
        )

        @Argument(help: "Name or index of the process to delete, or 'all' to delete all processes.")
        var nameOrIndex: String

        func run() throws {
            if nameOrIndex.lowercased() == "all" {
                try deleteAllProcesses()
            } else if let index = Int(nameOrIndex) {
                // Delete process by index
                try deleteProcess(atIndex: index)
            } else {
                // Delete process by name
                try deleteProcess(named: nameOrIndex)
            }
        }

        func deleteProcess(named name: String) throws {
            print("Deleting process: \(name)")

            guard let processInfo = try ProcessManager.fetchProcessInfo(for: name) else {
                print("No process found with name: \(name)")
                return
            }

            // Remove process info
            try ProcessManager.removeProcessInfo(for: name)

            // Remove log file
            let logFilePath = processInfo.logFilePath
            if FileManager.default.fileExists(atPath: logFilePath) {
                try FileManager.default.removeItem(atPath: logFilePath)
            }

            print("Process \(name) has been deleted from SRM.")
        }

        func deleteProcess(atIndex index: Int) throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if index < 1 || index > processInfos.count {
                print("Invalid process index: \(index)")
                return
            }

            let processInfo = processInfos[index - 1]
            try deleteProcess(named: processInfo.processName)
        }

        func deleteAllProcesses() throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if processInfos.isEmpty {
                print("No processes to delete.")
                return
            }

            for processInfo in processInfos {
                try deleteProcess(named: processInfo.processName)
            }
        }
    }
}

// File: destroy.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/destroy.swift
//
//  destroy.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import ArgumentParser
import Foundation

extension SRM {
    struct Destroy: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Remove SRM CLI setup and clean up generated data.",
            discussion: """
            The `destroy` command removes SRM from your system.

            - Removes PATH entries from shell configuration files.
            - Deletes built binaries and log files.
            """
        )

        func run() throws {
            // Detect shell configuration files
            let shellConfigFiles = [".zshrc", ".bashrc", ".bash_profile", ".profile"]
            var configFileFound = false

            for fileName in shellConfigFiles {
                let configFile = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(fileName)
                if FileManager.default.fileExists(atPath: configFile.path) {
                    let buildPath = "$(pwd)/.build/release"
                    let exportLine = "export PATH=\"$PATH:\(buildPath)\""

                    // Remove the export line from the shell configuration file
                    var fileContents = try String(contentsOf: configFile, encoding: .utf8)
                    if fileContents.contains(exportLine) {
                        fileContents = fileContents.replacingOccurrences(of: exportLine, with: "")
                        try fileContents.write(to: configFile, atomically: true, encoding: .utf8)
                        print("SRM removed from \(configFile.path).")
                        configFileFound = true
                        break
                    }
                }
            }

            if !configFileFound {
                print("No SRM PATH entry found in shell configuration files.")
            }

            // Delete the binary and the build directory
            let releaseDirectory = FileManager.default.currentDirectoryPath.appending("/.build/release")
            if FileManager.default.fileExists(atPath: releaseDirectory) {
                try FileManager.default.removeItem(atPath: releaseDirectory)
                print("Deleted release directory: \(releaseDirectory).")
            }

            // Delete log and other generated files (if any)
            let logsDirectory = ProcessManager.logsDirectory
            if FileManager.default.fileExists(atPath: logsDirectory.path) {
                try FileManager.default.removeItem(at: logsDirectory)
                print("Deleted logs and generated data at \(logsDirectory.path).")
            } else {
                print("No logs or generated data found.")
            }

            print("SRM destroy process completed.")
            print("Please restart your terminal to apply the changes.")
        }
    }
}

// File: list.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/list.swift
//
//  list.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import ArgumentParser
import Foundation
import ShellOut
import CLITable

extension SRM {
    struct List: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "List all running processes.",
            discussion: """
            The `list` command displays all processes currently managed by SRM.

            Example:
              - List processes: `srm list`
            """,
            aliases: ["ls"]
        )
        
        func run() throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()

            if processInfos.isEmpty {
                print("No processes found.")
                return
            }

            // Create headers for the table, including Index
            let headers = ["Index", "Name", "Status", "PID", "CPU%", "MEM%", "Start Time"]

            // Initialize the table with headers
            var table = CLITable(headers: headers)

            for (index, processInfo) in processInfos.enumerated() {
                var status = processInfo.status
                let pid = processInfo.processIdentifier ?? 0
                let startTime = processInfo.startTime != nil ? formatDate(processInfo.startTime!) : "N/A"
                var cpuUsage = "N/A"
                var memUsage = "N/A"

                if let pid = processInfo.processIdentifier, isProcessRunning(pid: pid) {
                    cpuUsage = getCPUUsage(pid: pid)
                    memUsage = getMemoryUsage(pid: pid)
                    status = "running"
                } else if status == "running" {
                    // Process was marked as running but is no longer running
                    status = "stopped"
                }

                // Add a row to the table
                table.addRow([
                    "\(index + 1)",
                    processInfo.processName,
                    status,
                    "\(pid)",
                    cpuUsage,
                    memUsage,
                    startTime
                ])
            }

            // Display the table
            table.showTable()
        }

        func isProcessRunning(pid: Int32) -> Bool {
            #if os(Windows)
            // Windows-specific implementation
            return false // Placeholder
            #else
            return kill(pid, 0) == 0
            #endif
        }

        func getCPUUsage(pid: Int32) -> String {
            #if os(Linux)
            let command = "ps -p \(pid) -o %cpu --no-headers"
            #elseif os(macOS)
            let command = "ps -p \(pid) -o %cpu | tail -1"
            #else
            return "N/A"
            #endif

            do {
                let output = try shellOut(to: command)
                return output.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
            } catch {
                return "N/A"
            }
        }

        func getMemoryUsage(pid: Int32) -> String {
            #if os(Linux)
            let command = "ps -p \(pid) -o %mem --no-headers"
            #elseif os(macOS)
            let command = "ps -p \(pid) -o %mem | tail -1"
            #else
            return "N/A"
            #endif

            do {
                let output = try shellOut(to: command)
                return output.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
            } catch {
                return "N/A"
            }
        }

        func formatDate(_ date: Date) -> String {
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
            return formatter.string(from: date)
        }
    }
}

// File: logs.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/logs.swift
//
//  logs.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import ArgumentParser
import Foundation

extension SRM {
    struct Logs: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "View logs of a process.",
            discussion: """
            The `logs` command displays the logs of a managed process.
            
            Examples:
              - View last 10 lines and follow: `srm logs MyApp`
              - View last 50 lines and follow: `srm logs MyApp --lines 50`
              - View logs without following: `srm logs MyApp --no-follow`
              - View logs for all processes: `srm logs all`
            """
        )
        
        @Argument(help: "Name or index of the process to fetch logs for, or 'all' to fetch logs for all processes.")
        var nameOrIndex: String
        
        @Option(name: .shortAndLong, help: "Number of lines to display.")
        var lines: Int = 10
        
        @Flag(name: .shortAndLong, help: "Do not tail logs in real-time.")
        var noFollow: Bool = false
        
        func run() throws {
            if nameOrIndex.lowercased() == "all" {
                try showLogsForAllProcesses()
            } else if let index = Int(nameOrIndex) {
                // Adjust index for zero-based array
                try showLogs(forProcessAtIndex: index)
            } else {
                // Show logs for process by name
                try showLogs(forProcessNamed: nameOrIndex)
            }
        }
        
        func showLogs(forProcessNamed name: String) throws {
            let logFilePath = ProcessManager.logsDirectory.appendingPathComponent("\(name).log").path
            
            if FileManager.default.fileExists(atPath: logFilePath) {
                if !noFollow {
                    // Tail logs in real-time
                    tailLogFile(atPath: logFilePath, processName: name, lines: lines)
                } else {
                    // Only display the specified number of lines
                    let logData = try String(contentsOfFile: logFilePath, encoding: .utf8)
                    let logLines = logData.split(separator: "\n").suffix(lines)
                    
                    print("Last \(lines) lines of logs for \(name):")
                    for line in logLines {
                        print("[\(name)] \(line)")
                    }
                }
            } else {
                print("No logs found for process: \(name)")
            }
        }
        
        func showLogs(forProcessAtIndex index: Int) throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if index < 1 || index > processInfos.count {
                print("Invalid process index: \(index)")
                return
            }
            
            let processInfo = processInfos[index - 1] // Adjust for zero-based index
            try showLogs(forProcessNamed: processInfo.processName)
        }
        
        func showLogsForAllProcesses() throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if processInfos.isEmpty {
                print("No processes found.")
                return
            }
            
            var logLines = [(String, String)]() // Tuple to hold (process name, log line)

            // Read the last N lines from all log files
            for processInfo in processInfos {
                let logFilePath = ProcessManager.logsDirectory.appendingPathComponent("\(processInfo.processName).log")
                
                guard FileManager.default.fileExists(atPath: logFilePath.path) else {
                    print("No logs found for process: \(processInfo.processName)")
                    continue
                }

                let logData = try String(contentsOfFile: logFilePath.path, encoding: .utf8)
                let lines = logData.split(separator: "\n").suffix(self.lines)
                for line in lines {
                    logLines.append((processInfo.processName, String(line)))
                }
            }

            // Sort log lines by their timestamp (assuming the format includes a timestamp)
            logLines.sort { lhs, rhs in
                extractTimestamp(from: lhs.1) < extractTimestamp(from: rhs.1)
            }

            // Print the sorted log lines
            for (processName, line) in logLines {
                print("[\(processName)] \(line)")
            }

            if !noFollow {
                print("Tailing logs for all processes. Press Ctrl+C to stop.")
                tailLogsForAllProcesses(processInfos: processInfos)
            }
        }

        func extractTimestamp(from logLine: String) -> Date {
            // Assuming the timestamp format is: [YYYY-MM-DD HH:MM:SS]
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "[yyyy-MM-dd HH:mm:ss]"
            
            let components = logLine.split(separator: "]", maxSplits: 1, omittingEmptySubsequences: true)
            if let dateString = components.first?.trimmingCharacters(in: .whitespacesAndNewlines) {
                return dateFormatter.date(from: dateString) ?? Date.distantPast
            }
            return Date.distantPast
        }

        func tailLogsForAllProcesses(processInfos: [CodableProcessInfo]) {
            var allFileHandles: [FileHandle] = []

            defer {
                allFileHandles.forEach { $0.closeFile() }
            }
            
            for processInfo in processInfos {
                let logFilePath = ProcessManager.logsDirectory.appendingPathComponent("\(processInfo.processName).log")
                
                guard FileManager.default.fileExists(atPath: logFilePath.path) else {
                    continue
                }
                
                guard let fileHandle = FileHandle(forReadingAtPath: logFilePath.path) else {
                    continue
                }
                
                allFileHandles.append(fileHandle)
                fileHandle.seekToEndOfFile()

                // Observe each file for new data
                let processName = processInfo.processName
                fileHandle.readabilityHandler = { handle in
                    let data = handle.availableData
                    if let logEntry = String(data: data, encoding: .utf8) {
                        let lines = logEntry.split(separator: "\n")
                        for line in lines {
                            print("[\(processName)] \(line)")
                        }
                    }
                }
            }

            // Keep the run loop alive
            RunLoop.current.run()
        }
        
        func tailLogFile(atPath path: String, processName: String, lines: Int) {
            // Read the last N lines
            if let logData = try? String(contentsOfFile: path, encoding: .utf8) {
                let logLines = logData.split(separator: "\n").suffix(lines)
                for line in logLines {
                    print("[\(processName)] \(line)")
                }
            }
            
            guard let fileHandle = FileHandle(forReadingAtPath: path) else {
                print("Unable to open log file for \(processName).")
                return
            }
            
            // Move to the end of the file
            fileHandle.seekToEndOfFile()
            
            print("Tailing logs for \(processName). Press Ctrl+C to stop.")
            
            // Observe the file for new data
            fileHandle.readabilityHandler = { handle in
                let data = handle.availableData
                if let logEntry = String(data: data, encoding: .utf8) {
                    print("[\(processName)] \(logEntry)", terminator: "")
                }
            }
            
            // Keep the run loop alive
            RunLoop.current.run()
        }
    }
}

// File: minotor.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/minotor.swift
//
//  minotor.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 10.10.2024.
//

import ArgumentParser
import Foundation
import ShellOut

extension SRM {
    struct Monitor: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Start the SRM monitoring service (intended to run at system startup only)."
        )

        private var pidFilePath = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".srm/monitor.pid")

        func run() throws {
            // Step 1: Prevent manual execution by checking the environment variable
            guard ProcessInfo.processInfo.environment["SRM_AUTOMATIC_RUN"] == "true" else {
                print("The 'srm monitor' command is intended to run automatically at startup only and should not be called manually.")
                return
            }

            // Step 2: Check if the monitor is already running
            if let existingPID = try? String(contentsOf: pidFilePath, encoding: .utf8),
               let pid = Int32(existingPID),
               isProcessRunning(pid: pid) {
                print("SRM monitor is already running with PID: \(pid). Exiting to prevent multiple instances.")
                return
            }

            // Step 3: Write the current process's PID to the PID file
            let currentPID = ProcessInfo.processInfo.processIdentifier
            try "\(currentPID)".write(to: pidFilePath, atomically: true, encoding: .utf8)

            // Step 4: Start the monitoring loop
            print("Starting SRM monitoring service with PID: \(currentPID)...")

            // Step 5: Restart processes that were previously running
            try restartPreviouslyRunningProcesses()

            // Step 6: Monitor the processes
            while true {
                let processInfos = try ProcessManager.fetchAllProcessInfos()

                for var processInfo in processInfos {
                    if processInfo.status == "error" || processInfo.status == "stopped" {
                        continue
                    }

                    if let pid = processInfo.processIdentifier, !isProcessRunning(pid: pid) {
                        if processInfo.restart {
                            print("Process \(processInfo.processName) has stopped. Restarting...")
                            try restartProcess(processInfo: &processInfo)
                        } else {
                            processInfo.status = "stopped"
                            processInfo.processIdentifier = nil
                            processInfo.startTime = nil
                            try ProcessManager.saveProcessInfo(processInfo)
                            print("Process \(processInfo.processName) has stopped and will not be restarted.")
                        }
                    }
                }

                Thread.sleep(forTimeInterval: 5)
            }
        }

        private func restartPreviouslyRunningProcesses() throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()

            for var processInfo in processInfos {
                if processInfo.status == "running" {
                    print("Restarting process \(processInfo.processName) that was previously running...")
                    try restartProcess(processInfo: &processInfo)
                }
            }
        }

        private func restartProcess(processInfo: inout CodableProcessInfo) throws {
            let name = processInfo.processName
            let executable = processInfo.executable
            let logFilePath = processInfo.logFilePath

            let command = """
            nohup stdbuf -oL \(executable) > \(logFilePath) 2>&1 & echo $! && disown
            """

            do {
                let output = try shellOut(to: command)
                let pidString = output.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
                guard let pid = Int32(pidString) else {
                    throw RuntimeError("Failed to retrieve PID of the restarted process.")
                }

                processInfo.processIdentifier = pid
                processInfo.startTime = Date()
                processInfo.status = "running"
                try ProcessManager.saveProcessInfo(processInfo)

                print("Process \(name) restarted with PID: \(pid).")
            } catch {
                print("Failed to restart process \(name): \(error)")
                processInfo.status = "error"
                processInfo.processIdentifier = nil
                processInfo.startTime = nil
                try ProcessManager.saveProcessInfo(processInfo)
            }
        }

        private func isProcessRunning(pid: Int32) -> Bool {
            return kill(pid, 0) == 0
        }
    }
}

// File: restart.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/restart.swift
//
//  restart.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 10.10.2024.
//

import ArgumentParser
import Foundation
import ShellOut

extension SRM {
    struct Restart: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Restart a process managed by SRM.",
            discussion: """
            The `restart` command restarts a process by its name or index.

            Examples:
              - Restart a process by name: `srm restart MyApp`
              - Restart a process by index: `srm restart 1`
              - Restart all processes: `srm restart all`
            """
        )

        @Argument(help: "Name or index of the process to restart, or 'all' to restart all processes.")
        var nameOrIndex: String

        func run() throws {
            if nameOrIndex.lowercased() == "all" {
                try restartAllProcesses()
            } else if let index = Int(nameOrIndex) {
                // Restart process by index
                try restartProcess(atIndex: index)
            } else {
                // Restart process by name
                try restartProcess(named: nameOrIndex)
            }
        }

        func restartProcess(named name: String) throws {
            print("Restarting process: \(name)")

            guard let processInfo = try ProcessManager.fetchProcessInfo(for: name) else {
                print("No process found with name: \(name)")
                return
            }

            // Stop the process if it's running
            if let pid = processInfo.processIdentifier, isProcessRunning(pid: pid) {
                #if os(Windows)
                // Windows-specific kill command
                let command = "taskkill /PID \(pid) /F"
                #else
                // Unix-like kill command
                let command = "kill \(pid)"
                #endif
                try shellOut(to: command)
                print("Process \(name) with PID \(pid) has been stopped.")
            }

            // Set status to "stopped"
            var updatedProcessInfo = processInfo
            updatedProcessInfo.status = "stopped"
            updatedProcessInfo.processIdentifier = nil
            updatedProcessInfo.startTime = nil
            try ProcessManager.saveProcessInfo(updatedProcessInfo)
            
            // Start the process again
            var startCommand = Start()
            startCommand.executableOrName = processInfo.executable
            startCommand.name = processInfo.processName
            startCommand.restart = processInfo.restart
            startCommand.watch = false
            try startCommand.run()
        }

        func restartProcess(atIndex index: Int) throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if index < 1 || index > processInfos.count {
                print("Invalid process index: \(index)")
                return
            }

            let processInfo = processInfos[index - 1]
            try restartProcess(named: processInfo.processName)
        }

        func restartAllProcesses() throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if processInfos.isEmpty {
                print("No processes to restart.")
                return
            }

            for processInfo in processInfos {
                try restartProcess(named: processInfo.processName)
            }
        }

        func isProcessRunning(pid: Int32) -> Bool {
            #if os(Windows)
            // Windows-specific implementation
            return false // Placeholder
            #else
            return kill(pid, 0) == 0
            #endif
        }
    }
}

// File: setup.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/setup.swift
//
//  setup.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import ArgumentParser
import Foundation
import ShellOut

extension SRM {
    struct Setup: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Setup the SRM CLI globally.",
            discussion: """
            The `setup` command builds the SRM tool and adds it to your PATH.
            """
        )

        func run() throws {
            // Step 1: Create necessary directories
            try createRequiredDirectories()

            // Step 2: Build the release version
            try buildRelease()

            // Step 3: Set up PATH
            try setupPath()

            // Step 4: Set up service based on OS
            try setupService()
            
            print("\n‚ú® SRM setup completed successfully!")
            print("üöÄ Type 'srm --help' command for info.")
        }

        private func createRequiredDirectories() throws {
            // Create .srm directory in home
            let srmDir = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".srm")
            try FileManager.default.createDirectory(at: srmDir, withIntermediateDirectories: true, attributes: nil)
            
            // Create logs directory
            try FileManager.default.createDirectory(at: ProcessManager.logsDirectory, withIntermediateDirectories: true, attributes: nil)
            
            // Set proper permissions
            try shellOut(to: "chmod", arguments: ["755", srmDir.path])
            try shellOut(to: "chmod", arguments: ["755", ProcessManager.logsDirectory.path])
        }

        private func buildRelease() throws {
            print("Building SRM in release mode...")
            try shellOut(to: "swift build -c release")
        }

        private func setupPath() throws {
            let buildPath = FileManager.default.currentDirectoryPath + "/.build/release"
            let exportLine = "\n# Swift Running Manager path:\nexport PATH=\"$PATH:\(buildPath)\"\n"
            
            // Try to modify shell config files
            let shellConfigFiles = [".bashrc", ".zshrc", ".bash_profile", ".profile"]
            var configUpdated = false
            var updatedConfigPath: String? = nil
            
            // Detect current shell
            let currentShell = try? shellOut(to: "echo $SHELL")
            
            for fileName in shellConfigFiles {
                let configPath = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(fileName)
                if FileManager.default.fileExists(atPath: configPath.path) {
                    var content = (try? String(contentsOf: configPath, encoding: .utf8)) ?? ""
                    if !content.contains(buildPath) {
                        content += exportLine
                        try content.write(to: configPath, atomically: true, encoding: .utf8)
                        print("Updated PATH in \(fileName)")
                        configUpdated = true
                        updatedConfigPath = configPath.path
                        break
                    }
                }
            }
            
            if !configUpdated {
                print("Warning: Could not update PATH in any shell configuration file.")
                return
            }
            
            // Re-source the environment based on the current shell
            if let configPath = updatedConfigPath {
                print("\nApplying changes to current shell environment...")
                
                // Attempt to source the updated config file
                if let shell = currentShell?.trimmingCharacters(in: .whitespacesAndNewlines) {
                    do {
                        switch shell {
                        case let sh where sh.hasSuffix("/bash"):
                            try shellOut(to: "bash -c 'source \(configPath)'")
                            print("Sourced bash configuration.")
                        case let sh where sh.hasSuffix("/zsh"):
                            try shellOut(to: "zsh -c 'source \(configPath)'")
                            print("Sourced zsh configuration.")
                        default:
                            // For other shells, try a generic source approach
                            try shellOut(to: "source \(configPath)")
                            print("Attempted to source shell configuration.")
                        }
                        // Export the PATH directly for the current session
                        try shellOut(to: "export PATH=\"$PATH:\(buildPath)\"")
                        
                        print("\nEnvironment has been updated successfully.")
                        print("Note: Some shells may require you to start a new terminal session for changes to take full effect.")
                    } catch {
                        print("\nWarning: Could not automatically apply changes to the current shell.")
                        print("Please run the following command manually or start a new terminal session:")
                        print("    source \(configPath)")
                    }
                }
            }
        }

        private func setupService() throws {
            #if os(Linux)
            try setupSystemdService()
            #elseif os(macOS)
            try setupLaunchdService()
            #endif
        }

        private func setupSystemdService() throws {
            let serviceContent = """
            [Unit]
            Description=SRM Monitoring Service
            After=network.target

            [Service]
            Type=simple
            User=\(NSUserName())
            Environment="SRM_AUTOMATIC_RUN=true"
            ExecStart=\(FileManager.default.currentDirectoryPath)/.build/release/srm monitor
            Restart=always
            RestartSec=5

            [Install]
            WantedBy=multi-user.target
            """

            // First try user service
            let userServiceDir = FileManager.default.homeDirectoryForCurrentUser
                .appendingPathComponent(".config/systemd/user")
            
            do {
                try FileManager.default.createDirectory(at: userServiceDir,
                                                      withIntermediateDirectories: true,
                                                      attributes: nil)
                let servicePath = userServiceDir.appendingPathComponent("srm-monitor.service")
                try serviceContent.write(to: servicePath, atomically: true, encoding: .utf8)
                
                // Enable and start the user service
                try shellOut(to: "systemctl --user daemon-reload")
                try shellOut(to: "systemctl --user enable srm-monitor")
                try shellOut(to: "systemctl --user start srm-monitor")
                
                print("SRM monitor service has been set up as a user service.")
            } catch {
                print("Warning: Could not set up user service. Error: \(error)")
                print("Attempting to set up system service (requires sudo)...")
                
                // Create temporary file
                let tempFile = "/tmp/srm-monitor.service"
                try serviceContent.write(toFile: tempFile, atomically: true, encoding: .utf8)
                
                // Move to system directory using sudo
                try shellOut(to: "sudo mv \(tempFile) /etc/systemd/system/srm-monitor.service")
                try shellOut(to: "sudo systemctl daemon-reload")
                try shellOut(to: "sudo systemctl enable srm-monitor")
                try shellOut(to: "sudo systemctl start srm-monitor")
                
                print("SRM monitor service has been set up as a system service.")
            }
        }
        
        // macOS-specific launchd setup
        func setupLaunchdService() throws {
            let plistPath = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent("Library/LaunchAgents/com.srm.monitor.plist")
            let plistContent = """
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
                <key>Label</key>
                <string>com.srm.monitor</string>
                <key>ProgramArguments</key>
                <array>
                    <string>/usr/local/bin/srm</string>
                    <string>monitor</string>
                </array>
                <key>RunAtLoad</key>
                <true/>
                <key>KeepAlive</key>
                <true/>
            </dict>
            </plist>
            """
            
            // Write plist content
            try plistContent.write(to: plistPath, atomically: true, encoding: .utf8)
            
            // Check if the service is already loaded
            let loadStatus = try? shellOut(to: "launchctl", arguments: ["list", "com.srm.monitor"])
            if loadStatus != nil {
                print("SRM monitoring service already exists. Unloading to apply updates...")
                try shellOut(to: "launchctl", arguments: ["unload", plistPath.path])
            }
            
            // Load the new service
            try shellOut(to: "launchctl", arguments: ["load", plistPath.path])
            print("SRM monitoring service has been loaded with launchd.")
        }
    }
}

// File: start.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/start.swift
//
//  start.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import ArgumentParser
import Foundation
import ShellOut
import Dispatch

extension SRM {
    struct Start: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Start a new process managed by SRM.",
            discussion: """
            The `start` command allows you to run any executable, script, or command as a managed process.

            Examples:
              - Start a Swift app: `srm start /path/to/app --name MyApp`
              - Start a shell script: `srm start ./script.sh --name MyScript`
              - Start a command: `srm start "python script.py" --name PythonScript`

            Options:
              - Start all stopped processes: `srm start all`
              - You can specify a custom name using `--name`.
              - Use `--restart` to automatically restart the process if it crashes.
              - Use `--watch` to start the process and display its output in real-time.
            """
        )

        @Argument(help: "The script, command, or executable to run, or 'all' to start all stopped processes.")
        var executableOrName: String?
        
        @Option(name: .shortAndLong, help: "Specify a custom name for the process.")
        var name: String?
        
        @Flag(name: .shortAndLong, help: "Automatically restart the process if it exits unexpectedly.")
        var restart: Bool = false

        @Flag(name: .long, help: "Start the process and display its output in real-time.")
        var watch: Bool = false

        func run() throws {
            if executableOrName?.lowercased() == "all" {
                try startAllProcesses()
            } else if let executable = executableOrName {
                // Automatically detect if this should be a Swift target
                let isSwiftTarget = !FileManager.default.fileExists(atPath: executable) && executable.split(separator: ".").count == 1
                
                if isSwiftTarget {
                    try startSwiftTarget(targetName: executable, name: name, restart: restart, watch: watch)
                } else {
                    // Start a new process with the provided executable
                    try startProcess(executable: executable, name: name, restart: restart, watch: watch)
                }
            } else {
                print("Please provide an executable to start or 'all' to start all stopped processes.")
            }
        }

        func startSwiftTarget(targetName: String, name: String?, restart: Bool, watch: Bool) throws {
            let swiftRunCommand = "swift run \(targetName)"
            try startProcess(executable: swiftRunCommand, name: name, restart: restart, watch: watch)
        }

        func startProcess(executable: String, name: String?, restart: Bool, watch: Bool) throws {
            let processName = name ?? URL(fileURLWithPath: executable).lastPathComponent
            print("Starting process: \(processName)")
            
            // Ensure logs directory exists
            try FileManager.default.createDirectory(at: ProcessManager.logsDirectory, withIntermediateDirectories: true, attributes: nil)
            
            let logFileURL = ProcessManager.logsDirectory.appendingPathComponent("\(processName).log")
            
            // Rotate log if it exceeds size limit (e.g., 5 MB)
            let maxLogSize: UInt64 = 5 * 1024 * 1024 // 5 MB
            if let attributes = try? FileManager.default.attributesOfItem(atPath: logFileURL.path),
               let fileSize = attributes[FileAttributeKey.size] as? UInt64,
               fileSize > maxLogSize {
                // Move current log to archived log with timestamp
                let dateFormatter = DateFormatter()
                dateFormatter.dateFormat = "yyyyMMddHHmmss"
                let timestamp = dateFormatter.string(from: Date())
                let archivedLogPath = ProcessManager.logsDirectory.appendingPathComponent("\(processName)_\(timestamp).log")
                try FileManager.default.moveItem(atPath: logFileURL.path, toPath: archivedLogPath.path)
                print("Rotated log file to \(archivedLogPath.lastPathComponent)")
            }
            
            if watch {
                // Start the process in the foreground and capture output
                try startProcessWithWatch(executable: executable, processName: processName, logFileURL: logFileURL, restart: restart)
            } else {
                // Start the process in the background as before
                try startProcessInBackground(executable: executable, processName: processName, logFileURL: logFileURL, restart: restart)
            }
        }

        func startProcessWithWatch(executable: String, processName: String, logFileURL: URL, restart: Bool) throws {
            let process = Process()
            // Split the executable and its arguments
            let arguments = splitCommandLine(executable)
            guard let executablePath = arguments.first else {
                throw RuntimeError("Executable path is empty.")
            }
            process.executableURL = URL(fileURLWithPath: executablePath)
            process.arguments = Array(arguments.dropFirst())
            
            // Set up pipes to capture output
            let outputPipe = Pipe()
            let errorPipe = Pipe()
            process.standardOutput = outputPipe
            process.standardError = errorPipe
            
            // Create or open the log file
            if !FileManager.default.fileExists(atPath: logFileURL.path) {
                guard FileManager.default.createFile(atPath: logFileURL.path, contents: nil, attributes: nil) else {
                    throw RuntimeError("Failed to create log file at \(logFileURL.path)")
                }
            }
            let logFileHandle = try FileHandle(forWritingTo: logFileURL)
            logFileHandle.seekToEndOfFile()
            
            // Start the process
            try process.run()
            
            let pid = process.processIdentifier
            
            // Save process info with status "running"
            let processInfo = CodableProcessInfo(
                processName: processName,
                processIdentifier: pid,
                startTime: Date(),
                restart: restart,
                executable: executable,
                logFilePath: logFileURL.path,
                status: "running"
            )
            try ProcessManager.saveProcessInfo(processInfo)
            
            print("Process \(processName) started with PID: \(pid). Press Ctrl+C to stop.")
            
            // Handle SIGINT (Ctrl+C) using DispatchSourceSignal
            // Ignore default handling of SIGINT
            signal(SIGINT, SIG_IGN)
            
            // Create a DispatchSourceSignal for SIGINT
            let signalSource = DispatchSource.makeSignalSource(signal: SIGINT, queue: DispatchQueue.main)
            signalSource.setEventHandler {
                print("\nReceived interrupt signal. Terminating process \(processName)...")
                process.terminate()
                signalSource.cancel()
            }
            signalSource.resume()
            
            // Set up a dispatch group to wait for both output and error streams
            let dispatchGroup = DispatchGroup()
            
            // Handle standard output
            dispatchGroup.enter()
            outputPipe.fileHandleForReading.readabilityHandler = { handle in
                let data = handle.availableData
                if data.isEmpty {
                    outputPipe.fileHandleForReading.readabilityHandler = nil
                    dispatchGroup.leave()
                } else {
                    // Write to log file
                    logFileHandle.write(data)
                    // Print to terminal
                    if let output = String(data: data, encoding: .utf8) {
                        print(output, terminator: "")
                        fflush(stdout)
                    }
                }
            }
            
            // Handle standard error
            dispatchGroup.enter()
            errorPipe.fileHandleForReading.readabilityHandler = { handle in
                let data = handle.availableData
                if data.isEmpty {
                    errorPipe.fileHandleForReading.readabilityHandler = nil
                    dispatchGroup.leave()
                } else {
                    // Write to log file
                    logFileHandle.write(data)
                    // Print to terminal (you may want to format errors differently)
                    if let output = String(data: data, encoding: .utf8) {
                        fputs(output, stderr)
                        fflush(stderr)
                    }
                }
            }
            
            // Wait for the process to exit
            process.waitUntilExit()
            
            // Wait for output handling to finish
            dispatchGroup.wait()
            
            // Close file handles
            logFileHandle.closeFile()
            outputPipe.fileHandleForReading.closeFile()
            errorPipe.fileHandleForReading.closeFile()
            
            // Cancel the signal source
            signalSource.cancel()
            
            // Restore default signal handling
            signal(SIGINT, SIG_DFL)
            
            // Update process info to reflect that the process has exited
            var updatedProcessInfo = processInfo
            updatedProcessInfo.status = "stopped"
            updatedProcessInfo.processIdentifier = nil
            updatedProcessInfo.startTime = nil
            try ProcessManager.saveProcessInfo(updatedProcessInfo)
            
            print("\nProcess \(processName) has exited.")
        }

        func startProcessInBackground(executable: String, processName: String, logFileURL: URL, restart: Bool) throws {
            // Prepare the command
            let command = """
            nohup stdbuf -oL \(executable) > \(logFileURL.path) 2>&1 & echo $! && disown

            """
            
            // Prepare the process
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/sh")
            process.arguments = ["-c", command]
            
            // Create a pipe to capture the PID output
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            
            // Start the process
            try process.run()
            process.waitUntilExit()
            
            // Read the PID from the output
            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            if let pidString = String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines),
               let pid = Int32(pidString) {
                
                // Save process info with status "running"
                let processInfo = CodableProcessInfo(
                    processName: processName,
                    processIdentifier: pid,
                    startTime: Date(),
                    restart: restart,
                    executable: executable,
                    logFilePath: logFileURL.path,
                    status: "running"
                )
                try ProcessManager.saveProcessInfo(processInfo)
                
                print("Process \(processName) started with PID: \(pid).")
            } else {
                throw RuntimeError("Failed to retrieve PID of the started process.")
            }
        }

        func startAllProcesses() throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            let stoppedProcesses = processInfos.filter { $0.status == "stopped" || $0.status == "error" }
            
            if stoppedProcesses.isEmpty {
                print("No stopped processes to start.")
                return
            }
            
            for processInfo in stoppedProcesses {
                try startProcess(executable: processInfo.executable, name: processInfo.processName, restart: processInfo.restart, watch: false)
            }
        }
        
        private func splitCommandLine(_ commandLine: String) -> [String] {
            var args = [String]()
            var currentArg = ""
            var isInQuotes = false
            var iterator = commandLine.makeIterator()
            while let char = iterator.next() {
                if char == "\"" {
                    isInQuotes.toggle()
                } else if char == " " && !isInQuotes {
                    if !currentArg.isEmpty {
                        args.append(currentArg)
                        currentArg = ""
                    }
                } else {
                    currentArg.append(char)
                }
            }
            if !currentArg.isEmpty {
                args.append(currentArg)
            }
            return args
        }

    }
}

// File: stop.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/CLI/stop.swift
//
//  stop.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import ArgumentParser
import Foundation
import ShellOut

extension SRM {
    struct Stop: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Stop a running process managed by SRM.",
            discussion: """
            The `stop` command stops a running process by its name or index.

            Examples:
              - Stop a process by name: `srm stop MyApp`
              - Stop a process by index: `srm stop 1`
              - Stop all processes: `srm stop all`
            """
        )
        
        @Argument(help: "Name or index of the process to stop, or 'all' to stop all processes.")
        var nameOrIndex: String

        func run() throws {
            if nameOrIndex.lowercased() == "all" {
                try stopAllProcesses()
            } else if let index = Int(nameOrIndex) {
                // Stop process by index
                try stopProcess(atIndex: index)
            } else {
                // Stop process by name
                try stopProcess(named: nameOrIndex)
            }
        }

        func stopProcess(named name: String) throws {
            print("Stopping process: \(name)")

            do {
                guard var processInfo = try ProcessManager.fetchProcessInfo(for: name) else {
                    print("No process found with name: \(name)")
                    return
                }

                if let pid = processInfo.processIdentifier, isProcessRunning(pid: pid) {
                    #if os(Windows)
                    // Windows-specific kill command
                    let command = "taskkill /PID \(pid) /F"
                    #else
                    // Unix-like kill command
                    let command = "kill \(pid)"
                    #endif
                    try shellOut(to: command)
                    print("Process \(name) with PID \(pid) has been stopped.")
                } else {
                    print("Process \(name) is not running.")
                }

                // Update process info to set status to "stopped" and remove pid and startTime
                processInfo.status = "stopped"
                processInfo.processIdentifier = nil
                processInfo.startTime = nil
                try ProcessManager.saveProcessInfo(processInfo)
            } catch {
                print("An error occurred: \(error.localizedDescription)")
            }
        }

        func stopProcess(atIndex index: Int) throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if index < 1 || index > processInfos.count {
                print("Invalid process index: \(index)")
                return
            }

            let processInfo = processInfos[index - 1]
            try stopProcess(named: processInfo.processName)
        }

        func stopAllProcesses() throws {
            let processInfos = try ProcessManager.fetchAllProcessInfos()
            if processInfos.isEmpty {
                print("No processes to stop.")
                return
            }

            for processInfo in processInfos {
                try stopProcess(named: processInfo.processName)
            }
        }

        func isProcessRunning(pid: Int32) -> Bool {
            #if os(Windows)
            // Windows-specific implementation
            return false // Placeholder
            #else
            return kill(pid, 0) == 0
            #endif
        }
    }
}

// File: ProcessManager.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/Utils/ProcessManager.swift
//
//  ProcessManager.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import Foundation

struct CodableProcessInfo: Codable {
    let processName: String
    var processIdentifier: Int32?
    var startTime: Date?
    let restart: Bool
    let executable: String
    let logFilePath: String
    var status: String
}

struct ProcessManager {
    static let logsDirectory = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".srm/logs")

    static func saveProcessInfo(_ process: CodableProcessInfo) throws {
        let data = try JSONEncoder().encode(process)
        let filePath = logsDirectory.appendingPathComponent("\(process.processName).json")
        try data.write(to: filePath)
    }

    static func fetchProcessInfo(for name: String) throws -> CodableProcessInfo? {
        let filePath = logsDirectory.appendingPathComponent("\(name).json")
        guard FileManager.default.fileExists(atPath: filePath.path) else {
            return nil
        }
        let data = try Data(contentsOf: filePath)
        return try JSONDecoder().decode(CodableProcessInfo.self, from: data)
    }
    
    static func removeProcessInfo(for name: String) throws {
        let filePath = logsDirectory.appendingPathComponent("\(name).json")
        if FileManager.default.fileExists(atPath: filePath.path) {
            try FileManager.default.removeItem(at: filePath)
        }

        let logFilePath = logsDirectory.appendingPathComponent("\(name).log")
        if FileManager.default.fileExists(atPath: logFilePath.path) {
            try FileManager.default.removeItem(at: logFilePath)
        }
    }

    static func fetchAllProcessInfos() throws -> [CodableProcessInfo] {
        let files = try FileManager.default.contentsOfDirectory(at: logsDirectory, includingPropertiesForKeys: nil)
        let jsonFiles = files.filter { $0.pathExtension == "json" }
        var processInfos: [CodableProcessInfo] = []

        for file in jsonFiles {
            let data = try Data(contentsOf: file)
            if let processInfo = try? JSONDecoder().decode(CodableProcessInfo.self, from: data) {
                processInfos.append(processInfo)
            }
        }
        return processInfos.sorted(by: {
            guard let one = $0.startTime else { return false }
            guard let two = $1.startTime else { return true }
            return one < two
        })
    }
}

// File: main.swift | Path: /Users/maximlanskoy/SRM/Sources/SRM/main.swift
//
//  main.swift
//  Swift Running Manager
//
//  Created by Maxim Lanskoy on 11.09.2024.
//

import ArgumentParser
import Foundation

// Define RuntimeError type
struct RuntimeError: Error, CustomStringConvertible {
    var description: String

    init(_ description: String) {
        self.description = description
    }
}

// Define SRM structure without the @main attribute
struct SRM: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "Swift Running Manager (SRM)",
        subcommands: [
            Start.self,
            Stop.self,
            Restart.self,
            List.self,
            Logs.self,
            Monitor.self,
            Setup.self,
            Destroy.self,
            Delete.self,
            HelpCommand.self
        ],
        defaultSubcommand: HelpCommand.self
    )

    struct HelpCommand: ParsableCommand {
        static let configuration = CommandConfiguration(
            commandName: "help",
            abstract: "Display help information"
        )

        func run() throws {
            print("""
            SRM - Swift Running Manager
            Usage: srm <command> [options]

            Commands:
                start     Start a process
                stop      Stop a process
                list (ls) List all running processes
                logs      View logs of a process
                monitor   Start the monitoring service
                setup     Setup SRM
                destroy   Remove SRM setup
                help      Display this help information

            Use 'srm <command> --help' for more information on a command.
            """)
        }
    }
}

SRM.main()
